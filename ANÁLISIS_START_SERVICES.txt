================================================================================
ANÁLISIS COMPARATIVO: Por qué start-services.sh falla vs start-db.sh funciona
================================================================================
Fecha: 4 Diciembre 2025

================================================================================
1. DIFERENCIAS PRINCIPALES
================================================================================

start-services.sh:
├─ Usa: docker-compose build
├─ Usa: docker-compose up
├─ Levanta: 3 servicios simultáneamente (db, backend, frontend)
└─ Problema: Docker, dependencias de entorno, configuración

start-db.sh:
├─ Usa: npm install (directamente)
├─ Usa: npm run dev (directamente con tsx)
├─ Levanta: solo DB Service
└─ Ventaja: Sin Docker, ejecución directa en host

================================================================================
2. RAZONES DE FALLOS EN docker-compose
================================================================================

PROBLEMA #1: Variables de entorno no definidas
───────────────────────────────────────────
Ubicación: docker-compose.yml línea 11-13
```
environment:
  - DB_SERVICE_PORT=${DB_SERVICE_PORT}
  - DB_SERVICE_HOST=${DB_SERVICE_HOST}
```
Causas posibles:
  ❌ Archivo .env no existe o no está cargado
  ❌ Variables no están definidas en el host
  ❌ docker-compose no lee el .env correctamente
Efecto:
  → Los servicios reciben variables vacías o indefinidas
  → El servidor intenta escuchar en puerto undefined
  → Falla al intentar binding

SOLUCIÓN:
  ✅ Verificar que /workspaces/42_transendence/.env existe
  ✅ Contiene: DB_SERVICE_PORT=3001, DB_SERVICE_HOST=0.0.0.0, etc.
  ✅ O proporcionar valores por defecto en docker-compose.yml

PROBLEMA #2: Dependencia de servicios
───────────────────────────────────────
Ubicación: docker-compose.yml línea 40
```
depends_on:
  - db
```
Causas posibles:
  ❌ Backend intenta conectar a db-service antes de que esté listo
  ❌ db-service tarda en inicializar (npm install, node_modules compilation)
  ❌ depends_on NO espera a que el servicio esté "ready" (solo a que el container inicie)
Efecto:
  → Backend inicia antes de que DB esté escuchando
  → Conexiones fallidas
  → El stack completo falla

SOLUCIÓN:
  ✅ Usar healthchecks en docker-compose
  ✅ O levantar servicios uno por uno (como haces ahora)

PROBLEMA #3: Construcción de múltiples imágenes
────────────────────────────────────────────────
Ubicación: start-services.sh línea 17
```bash
docker-compose build
```
Causas posibles:
  ❌ Dockerfile de backend/frontend también intenta construirse
  ❌ Si alguno de los Dockerfiles tiene error → FALLAN TODOS
  ❌ npm install en múltiples servicios simultáneamente = I/O contention
Efecto:
  → Fallos en cascada
  → Difícil de debuggear (multiple services failing)

SOLUCIÓN:
  ✅ Levantar servicios por separado: docker-compose up db
  ✅ O usar docker-compose build db (solo ese servicio)

PROBLEMA #4: Network no existe antes de crearse
──────────────────────────────────────────────
Ubicación: docker-compose.yml línea 80-82
```
networks:
  ft-transcendence:
    driver: bridge
```
Causas posibles:
  ❌ Si es primer run, la network no existe
  ❌ Si hubo containers previos con mismo nombre, pueden haber conflictos
Efecto:
  → Containers no se comunican entre sí
  → db-service es inaccesible desde backend

SOLUCIÓN:
  ✅ docker network prune (limpiar redes antiguas)
  ✅ O confiar en docker-compose para crearlas

PROBLEMA #5: Volumenes sin permisos
────────────────────────────────────
Ubicación: docker-compose.yml línea 7-8
```
volumes:
  - ./db/data:/app/data
```
Causas posibles:
  ❌ Directorio ./db/data no existe
  ❌ Permisos incorrectos de escritura
  ❌ SQLite intenta crear app.db en /app/data sin permisos
Efecto:
  → Error de I/O al crear/escribir database
  → El servicio DB falla en inicialización

SOLUCIÓN:
  ✅ Crear directorio antes: mkdir -p ./db/data
  ✅ Dar permisos: chmod 777 ./db/data
  ✅ O usar tmpfs para desarrollo

================================================================================
3. POR QUÉ start-db.sh FUNCIONA
================================================================================

✅ VENTAJA #1: Sin Docker (ejecución directa en host)
  - No hay capas de virtualización
  - No hay problemas de network entre containers
  - npm install directo = más rápido para desarrollo

✅ VENTAJA #2: npm run dev con tsx
  - tsx compila y ejecuta TypeScript en tiempo real
  - No necesita compilación previa
  - Hot reload funciona mejor localmente

✅ VENTAJA #3: Sin dependencias de otros servicios
  - DB se levanta independientemente
  - Sin problemas de depends_on
  - Sin esperar a que otro servicio inicie

✅ VENTAJA #4: Variables de entorno simplificadas
  - Usa valores por defecto en código (puerto 3001, localhost)
  - No depende de archivo .env
  - Más predecible para desarrollo

✅ VENTAJA #5: Debugging más fácil
  - Logs directamente en terminal actual
  - Errores visibles inmediatamente
  - Stack traces completos

================================================================================
4. CÓMO ARREGLAR start-services.sh
================================================================================

OPCIÓN A: Usar docker-compose correctamente (recomendado para producción)
──────────────────────────────────────────────────────────────────────

1. Crear/verificar archivo .env en raíz:
```bash
DB_SERVICE_PORT=3001
DB_SERVICE_HOST=0.0.0.0
BACKEND_PORT=3000
BACKEND_HOST=0.0.0.0
FRONTEND_PORT=8080
FRONTEND_HOST=0.0.0.0
GATEWAY_URL=http://localhost:3001
```

2. Asegurar que directorio de datos existe:
```bash
mkdir -p /workspaces/42_transendence/db/data
chmod 777 /workspaces/42_transendence/db/data
```

3. Limpiar networks antiguas:
```bash
docker network prune -f
```

4. Mejorar docker-compose.yml con healthchecks y valores por defecto:
```yaml
db:
  # ... existing config ...
  healthcheck:
    test: ["CMD", "node", "-e", "require('http').get('http://localhost:3001/health', (r) => {if (r.statusCode !== 200) throw new Error(r.statusCode)})"]
    interval: 5s
    timeout: 3s
    retries: 5
    start_period: 10s

backend:
  depends_on:
    db:
      condition: service_healthy  # ← Esperar a que sea healthy, no solo que inicie
```

OPCIÓN B: Usar ejecución local para desarrollo (más rápido, como ahora)
───────────────────────────────────────────────────────────────────────

Mantener:
- start-db.sh → Levanta DB localmente
- start-backend.sh → Levanta Backend localmente
- start-frontend.sh → Levanta Frontend localmente

Ventajas:
- Más rápido (sin Docker)
- Mejor para debugging
- Cada servicio independiente

================================================================================
5. CONCLUSIÓN TÉCNICA
================================================================================

La razón de fondo es que:

❌ docker-compose es para ORQUESTACIÓN de múltiples servicios (producción)
✅ npm run dev es para DESARROLLO local de un servicio

Mezclarlo sin:
  - Archivo .env correcto
  - Healthchecks en docker-compose
  - Esperar a que servicios estén ready
  - Directorios de datos creados

...resulta en fallos en cascada que son difíciles de debuggear.

RECOMENDACIÓN:
  Para desarrollo: usa start-db.sh + start-backend.sh en terminales separadas
  Para producción: usa docker-compose con archivo .env completo

================================================================================
