================================================================================
RESUMEN DE CAMBIOS REALIZADOS - PROYECTO 42_TRANSENDENCE
================================================================================
Fecha: 4 Diciembre 2025
Rama: 12-server_swagger
Usuario: outsiderice

================================================================================
OBJETIVO PRINCIPAL
================================================================================
Crear un servicio independiente de base de datos SQLite que se comunique con
el backend de Fastify mediante REST API, separando responsabilidades y 
permitiendo escalabilidad futura.

================================================================================
CAMBIOS REALIZADOS
================================================================================

1. CREACIÓN DEL SERVICIO DB (/db)
================================================================================

1.1 - package.json (/db/package.json)
   - Creado nuevo archivo de configuración
   - Dependencias añadidas:
     * better-sqlite3: ^9.2.2 (driver SQLite sincrónico)
     * fastify: ^5.6.2 (framework web)
     * dotenv: ^17.2.3 (variables de entorno)
   - Dev dependencies:
     * @types/better-sqlite3: ^7.6.8 (tipos TypeScript)
     * @types/node: ^24.10.1
     * tsx: ^4.20.6 (ejecutor TypeScript)
     * typescript: ^5.9.3
   - Scripts:
     * dev: npx tsx watch src/server.ts (desarrollo con hot reload)
     * build: tsc (compilación)
     * start: node dist/server.js (producción)

1.2 - tsconfig.json (/db/tsconfig.json)
   - Configuración TypeScript optimizada:
     * module: "esnext"
     * target: "esnext"
     * moduleResolution: "bundler"
     * esModuleInterop: true (permite importar módulos CommonJS como ESM)
     * allowSyntheticDefaultImports: true (importaciones por defecto)
     * strict: true (validación estricta)
   - Desactivadas opciones muy restrictivas para evitar conflictos de tipos

1.3 - Dockerfile (/db/Dockerfile)
   - Basado en node:24-alpine (imagen ligera)
   - WORKDIR: /app
   - Copia package.json y ejecuta npm install
   - Expone puerto 3001
   - CMD: npx tsx watch src/server.ts (desarrollo con hot reload)

1.4 - .env.example (/db/.env.example)
   - Variables de entorno para el servicio DB:
     * DB_SERVICE_PORT=3001 (puerto de escucha)
     * DB_SERVICE_HOST=0.0.0.0 (accesible desde cualquier IP)
     * DB_PATH=./data/app.db (ruta del archivo SQLite)

1.5 - .env (/db/.env)
   - Archivo de entorno para desarrollo
   - Contiene valores por defecto de variables

1.6 - .gitignore (/db/.gitignore)
   - Excluye: node_modules/, *.log, .env, .DS_Store, dist/, data/

1.7 - .dockerignore (/db/.dockerignore)
   - Excluye del contenedor Docker: node_modules/, .env, *.log, .DS_Store, data/

1.8 - README.md (/db/README.md)
   - Documentación completa del servicio DB
   - Instrucciones de instalación y uso
   - Listado de todos los endpoints CRUD
   - Variables de entorno
   - Ejemplos de Docker

1.9 - src/config/sqlite.ts (/db/src/config/sqlite.ts)
   - Configuración de la base de datos SQLite
   - Inicialización y creación de tablas:
     * users (id, username, email, password, nickname, avatar, timestamps)
     * games (jugador 1, jugador 2, ganador, estado)
     * chat_messages (usuario, mensaje, timestamp)
     * user_stats (wins, losses, draws por usuario)
   - Activación de foreign keys para integridad referencial
   - Export de instancia db y función initializeDatabase()

1.10 - src/modules/users/users.service.ts (/db/src/modules/users/users.service.ts)
   - Interfaz User con propiedades:
     * id, username, email, password, nickname, avatar, timestamps
   - Clase UsersService con métodos CRUD:
     * createUser(user): crea usuario y retorna con ID
     * getUserById(id): obtiene usuario por ID
     * getUserByUsername(username): obtiene por nombre de usuario
     * getUserByEmail(email): obtiene por email
     * getAllUsers(): obtiene todos los usuarios
     * updateUser(id, updates): actualiza parcialmente un usuario
     * deleteUser(id): elimina un usuario

1.11 - src/modules/users/users.routes.ts (/db/src/modules/users/users.routes.ts)
   - 6 endpoints REST con validaciones:
     * POST /users - Crear usuario (valida unicidad de username/email)
     * GET /users - Obtener todos
     * GET /users/:id - Obtener por ID
     * GET /users/by-username/:username - Obtener por username
     * PUT /users/:id - Actualizar usuario
     * DELETE /users/:id - Eliminar usuario
   - Todas las rutas incluyen:
     * Manejo de errores try-catch
     * Respuestas HTTP con códigos apropiados
     * Validaciones de entrada
     * Mensajes de error descriptivos

1.12 - src/server.ts (/db/src/server.ts)
   - Punto de entrada del servicio DB
   - Inicializa Fastify en puerto 3001 (configurable)
   - Registra rutas de usuarios con prefijo /api
   - Endpoint adicional GET /health para health checks
   - Manejo de errores en arranque

1.13 - Directorio /db/data
   - Creado para almacenar el archivo app.db de SQLite
   - Incluido en .gitignore para no versionar datos

================================================================================
2. MODIFICACIONES EN DOCKER COMPOSE (/docker-compose.yml)
================================================================================

2.1 - Nuevo servicio 'db'
   - build: ./db
   - image: t_db
   - container_name: db-service
   - Volumen: ./db/data:/app/data (persiste BD entre contenedores)
   - Puerto: 3001:3001
   - Variables de entorno: DB_SERVICE_PORT, DB_SERVICE_HOST, DB_PATH
   - Red: ft-transcendence
   - Watch development: sincroniza cambios en tiempo real, rebuild en package.json

2.2 - Modificaciones en servicio 'backend'
   - Removido volumen: ./db:/app/db (ya no necesario)
   - Añadida variable: DB_SERVICE_URL=http://db-service:3001
   - Añadida dependencia: depends_on: [db] (espera a que DB inicie)
   - El backend ahora se conecta al DB vía HTTP REST

2.3 - Servicio 'frontend' (sin cambios)
   - Mantiene su configuración original

2.4 - Network 'ft-transcendence'
   - Mantiene tipo bridge para comunicación entre servicios

================================================================================
3. ACTUALIZACIÓN DE VARIABLES DE ENTORNO
================================================================================

3.1 - .env.example (raíz del proyecto)
   - Actualizado con todas las variables necesarias:
     * BACKEND_PORT=3000
     * BACKEND_HOST=0.0.0.0
     * DB_SERVICE_PORT=3001
     * DB_SERVICE_HOST=0.0.0.0
     * DB_PATH=./data/app.db
     * FRONTEND_PORT=8080
     * FRONTEND_HOST=0.0.0.0
     * GATEWAY_URL=http://localhost:3000
   - Comentarios explicativos añadidos

3.2 - .env (raíz del proyecto)
   - Creado archivo con valores por defecto para desarrollo

================================================================================
INSTALACIÓN Y DEPENDENCIAS EJECUTADAS
================================================================================

Comando ejecutado:
  cd /workspaces/42_transendence/db && npm install

Resultados:
  ✅ 94 paquetes instalados
  ✅ Auditoría completada sin vulnerabilidades

================================================================================
SOLUCIONES A PROBLEMAS DE TYPESCRIPT
================================================================================

Problema 1: Import de better-sqlite3
  Solución: Añadir assert { type: 'commonjs' } al import

Problema 2: Tipo de export db no se podía nombrar
  Solución: Importar tipo explícitamente y anotarlo en la variable
  import type { Database as DatabaseType } from 'better-sqlite3';
  export const db: DatabaseType = new Database(dbPath);

Problema 3: exactOptionalPropertyTypes muy restrictivo
  Solución: Desactivar en tsconfig.json
  - Cambió de exactOptionalPropertyTypes: true a false
  - Cambió noUncheckedIndexedAccess de true a false

================================================================================
ARQUITECTURA FINAL
================================================================================

Proyecto ahora tiene estructura de MICROSERVICIOS:

    Frontend (Puerto 8080)
         ↓ HTTP
    Backend (Puerto 3000)
         ↓ HTTP REST
    DB Service (Puerto 3001) → SQLite (./db/data/app.db)

Comunicación:
  - Frontend ↔ Backend: HTTP REST (vía GATEWAY_URL)
  - Backend ↔ DB Service: HTTP REST (vía DB_SERVICE_URL)
  - DB Service ↔ SQLite: Sincrónico (better-sqlite3)

Ventajas:
  ✅ Separación de responsabilidades clara
  ✅ Base de datos escalable (cambiar a PostgreSQL sin afectar backend)
  ✅ Fácil de dockerizar y orquestar
  ✅ Cada servicio independiente y reemplazable
  ✅ Comunicación via REST estándar

================================================================================
CÓMO LEVANTAR LOS SERVICIOS
================================================================================

OPCIÓN 1: Localmente (2 terminales)

Terminal 1 - DB Service:
  cd /workspaces/42_transendence/db
  npm install  (solo primera vez)
  npm run dev
  → Disponible en http://localhost:3001

Terminal 2 - Backend:
  cd /workspaces/42_transendence/backend
  npm install  (solo primera vez)
  npm run dev
  → Disponible en http://localhost:3000
  → Swagger en http://localhost:3000/docs

OPCIÓN 2: Con Docker Compose (1 comando)
  cd /workspaces/42_transendence
  docker compose up --build
  → DB en http://localhost:3001
  → Backend en http://localhost:3000
  → Frontend en http://localhost:8080

================================================================================
ENDPOINTS DISPONIBLES EN DB SERVICE
================================================================================

Base URL: http://localhost:3001/api (o http://db-service:3001/api en Docker)

USUARIOS:
  POST   /api/users              → Crear usuario
  GET    /api/users              → Obtener todos
  GET    /api/users/:id          → Obtener por ID
  GET    /api/users/by-username/:username → Obtener por username
  PUT    /api/users/:id          → Actualizar usuario
  DELETE /api/users/:id          → Eliminar usuario

HEALTH:
  GET    /health                 → Verificar estado del servicio

================================================================================
ARCHIVOS CREADOS
================================================================================

/db/
  ├── src/
  │   ├── config/
  │   │   └── sqlite.ts              (Configuración BD)
  │   ├── modules/
  │   │   └── users/
  │   │       ├── users.routes.ts    (Rutas CRUD)
  │   │       └── users.service.ts   (Lógica BD)
  │   └── server.ts                  (Punto de entrada)
  ├── data/                           (Directorio para BD)
  ├── package.json                   (Dependencias)
  ├── tsconfig.json                  (Config TypeScript)
  ├── Dockerfile                     (Config Docker)
  ├── .env.example                   (Variables entorno)
  ├── .env                           (Variables para desarrollo)
  ├── .gitignore                     (Excluir archivos)
  ├── .dockerignore                  (Excluir de Docker)
  └── README.md                      (Documentación)

ARCHIVOS MODIFICADOS:
  ├── /docker-compose.yml            (Añadido servicio db)
  ├── /.env.example                  (Actualizado variables)
  └── /.env                          (Creado archivo)

================================================================================
PRÓXIMOS PASOS RECOMENDADOS
================================================================================

1. Integrar cliente HTTP en backend
   - Usar axios o fetch para conectar con DB service
   - Crear servicios en backend que llamen a DB via REST

2. Implementar autenticación
   - Hash de contraseñas (bcrypt)
   - JWT tokens

3. Implementar otros módulos
   - Games CRUD
   - Chat CRUD
   - Stats CRUD

4. Testing
   - Tests unitarios con Jest
   - Tests de integración

5. Producción
   - Variables de entorno seguros
   - HTTPS/SSL
   - Rate limiting
   - Validaciones más robustas

================================================================================
FIN DEL RESUMEN
================================================================================

================================================================================
RESTAURACIÓN A VERSIÓN FUNCIONAL - 5 Diciembre 2025
================================================================================

PROBLEMA IDENTIFICADO:
- Versión anterior usaba sqlite3 con wrapper asincrónico que traía dependencia
  deprecated 'inflight@1.0.6' causando memory leaks
- User solicitó restaurar versión que "se levantó" correctamente

SOLUCIÓN IMPLEMENTADA:

1. REVERT a better-sqlite3 sincrónico (/db/package.json)
   - Cambio: sqlite ^5.0.1 + sqlite3 ^5.1.6 → better-sqlite3 ^9.2.2
   - Razón: better-sqlite3 es sincrónico, sin dependencias deprecated
   - Resultado: ✅ Eliminada dependencia inflight problemática

2. REVERT a sqlite.ts sincrónico (/db/src/config/sqlite.ts)
   - Patrón anterior: async open() con sqlite wrapper
   - Patrón actual: new Database() sincrónico de better-sqlite3
   - Cambios:
     * Removido import { open, Database } from 'sqlite'
     * Agregado import Database from 'better-sqlite3'
     * initializeDatabase() de async a sincrónico (void)
     * db.pragma() y db.exec() operaciones sincrónicas
     * Removida función getDb() async
   - CORRECCIÓN IMPORTANTE (línea 6):
     * Error: "Exported variable 'db' has or is using name 'BetterSqlite3.Database' from external module but cannot be named"
     * Solución: Agregar tipo explícito `BetterSqlite3.Database`
     * Cambio: export const db = new Database(dbPath);
               → import type BetterSqlite3 from 'better-sqlite3';
               → export const db: BetterSqlite3.Database = new Database(dbPath);
   - Resultado: ✅ Configuración sincrónica que es compatible con better-sqlite3

3. ACTUALIZACIÓN users.service.ts (/db/src/modules/users/users.service.ts)
   - Removido getDb() async en imports
   - Importación directa: import { db } from '../../config/sqlite'
   - Cambio de todos los métodos de async a sincrónico:
     * createUser(): Promise<User> → User
     * getUserById(): Promise<User | undefined> → User | undefined
     * getUserByUsername(): Promise<User | undefined> → User | undefined
     * getUserByEmail(): Promise<User | undefined> → User | undefined
     * getAllUsers(): Promise<User[]> → User[]
     * updateUser(): Promise<User | undefined> → User | undefined
     * deleteUser(): Promise<boolean> → boolean
   - Removido todos los await en llamadas a db.get(), db.run(), db.all()
   - Cambio de db.run() result.lastID → result.lastInsertRowid (API better-sqlite3)
   - Resultado: ✅ Métodos sincrónico compatibles con better-sqlite3

4. ACTUALIZACIÓN users.routes.ts (/db/src/modules/users/users.routes.ts)
   - Removidos await en llamadas a UsersService en todas las rutas:
     * POST /users: removeido await UsersService.createUser()
     * GET /users/:id: removido await UsersService.getUserById()
     * GET /users: removido await UsersService.getAllUsers()
     * GET /users/by-username/:username: removido await UsersService.getUserByUsername()
     * PUT /users/:id: removido await UsersService.updateUser()
     * DELETE /users/:id: removido await UsersService.deleteUser()
   - Las rutas mismas mantienen async para compatibilidad con Fastify
   - Resultado: ✅ Rutas ahora llaman métodos sincrónico correctamente

5. ACTUALIZACIÓN server.ts (/db/src/server.ts)
   - Cambio: await initializeDatabase() → initializeDatabase()
   - Razón: initializeDatabase() es ahora sincrónico
   - Resto del código (Swagger, rutas) sin cambios
   - Resultado: ✅ Inicialización sincrónica correcta

ESTADO ACTUAL:
✅ Completado: npm install ejecutado exitosamente (159 packages, 0 vulnerabilities)
✅ Completado: Toda la capa de servicio DB sincronizada con API sincrónico de better-sqlite3
✅ Completado: Error de TypeScript en sqlite.ts resuelto (tipo explícito BetterSqlite3.Database)
⏳ Pendiente: Levantamiento de servidores (docker-compose up)
⏳ Pendiente: Prueba funcional de endpoints

VALIDACIÓN TÉCNICA:
- API de better-sqlite3:
  * db.prepare(sql) - retorna statement sincrónico
  * stmt.run(...params) - ejecución sincrónica, retorna { lastInsertRowid, changes }
  * stmt.get(...params) - retorna un solo registro sincrónico
  * stmt.all(...params) - retorna array de registros sincrónico
- Toda la capa de negocios ahora usa métodos sincrónico → compatible
- Las rutas Fastify permanecen async → compatible con Fastify

ERRORES COMUNES A EVITAR (Lecciones aprendidas):
================================================================================
1. ERROR: "Exported variable has or is using name from external module but cannot be named"
   - CAUSA: Exportar variable tipada sin especificar tipo explícitamente
   - SOLUCIÓN: Agregar tipo explícito en la exportación
   - EJEMPLO: export const db: BetterSqlite3.Database = new Database(dbPath);
   - PREVENCIÓN: Siempre especificar tipos en exports de módulos externos

2. ERROR: async/await en métodos de better-sqlite3
   - CAUSA: Confundir better-sqlite3 (sincrónico) con sqlite3 (asincrónico)
   - SOLUCIÓN: Remover todos los await en llamadas a db.get(), db.run(), db.all()
   - VALIDACIÓN: better-sqlite3 NUNCA retorna Promises
   - PREVENCIÓN: Revisar documentación oficial antes de asumir API

3. ERROR: result.lastID vs result.lastInsertRowid
   - CAUSA: API diferente entre sqlite3 (lastID) y better-sqlite3 (lastInsertRowid)
   - SOLUCIÓN: Usar result.lastInsertRowid para better-sqlite3
   - PREVENCIÓN: Consultar tipos de TypeScript para validar propiedades disponibles

4. ERROR: Dependencia deprecated inflight (memory leaks)
   - CAUSA: sqlite3 trae transitive dependency en inflight@1.0.6
   - SOLUCIÓN: Usar better-sqlite3 que no tiene este problema
   - PREVENCIÓN: Revisar npm audit antes de usar en producción

5. ERROR: await initializeDatabase() cuando es sincrónico
   - CAUSA: No convertir función de async a sincrónico
   - SOLUCIÓN: Remover async/await cuando cambiar a API sincrónica
   - PREVENCIÓN: Marcar funciones como sincrónico (no async) si no retornan Promise

PRÓXIMOS PASOS:
1. Levantar servidores con docker-compose up
2. Probar que servicios se inicien sin errores
3. Validar endpoints en Swagger UI
4. Integración con backend si es necesario

================================================================================

